#!/bin/bash

# Default number of recent commits to consider
DEFAULT_N_COMMITS=1000

# Function to display usage information
usage() {
    echo "Usage: $0 [number_of_commits]"
    echo "If number_of_commits is not provided, it defaults to $DEFAULT_N_COMMITS"
    exit 1
}

# Check if the argument is a positive integer
is_positive_integer() {
    [[ $1 =~ ^[0-9]+$ ]] && (( $1 > 0 ))
}

# Parse command line argument
if [ $# -eq 0 ]; then
    N_COMMITS=$DEFAULT_N_COMMITS
elif [ $# -eq 1 ]; then
    if is_positive_integer "$1"; then
        N_COMMITS=$1
    else
        echo "Error: Argument must be a positive integer."
        usage
    fi
else
    usage
fi

# Temporary file to store results
temp_file=$(mktemp)

# Function to clean up and exit
cleanup() {
    echo "Script interrupted. Cleaning up..."
    rm -f "$temp_file"
    exit 1
}

# Set up trap to catch SIGINT (Ctrl+C)
trap cleanup SIGINT

# Function to get tag or short hash for a commit
get_tag_or_hash() {
    local commit=$1
    local tag=$(git describe --tags --exact-match $commit 2>/dev/null)
    if [ -n "$tag" ]; then
        echo "$tag"
    else
        echo "$commit"
    fi
}

# Get recent commit hashes across all branches
commits=$(git log --all --format="%h" -n $N_COMMITS)

# Loop through commits
while read -r commit; do
    # Get the list of files in this commit
    git ls-tree -r --name-only $commit | while read -r file; do
        # Check if this file has already been processed
        if ! grep -q "^$file " "$temp_file"; then
            tag_or_hash=$(get_tag_or_hash $commit)
            echo "$file $tag_or_hash" >> "$temp_file"
        fi
    done
done <<< "$commits"

# Sort and display the results
sort "$temp_file"

# Clean up
rm -f "$temp_file"
